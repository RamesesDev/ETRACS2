import com.rameses.annotations.*
import com.rameses.common.*
import java.rmi.server.UID

class DepositService
{
	@PersistenceContext('main')
	def em
	
	@Service('ETRACSUserService')
	def userSvc
	
	@Service('DateService')
	def dateSvc
	
	@Service('SequenceService')
	def sequenceSvc
	
	@Service('NumberService')
	def numSvc
	
	@Service('LogService')
	def logSvc
	
	def OPEN_STATE = 'OPEN'
	def CLOSED_STATE = 'CLOSED'
	def SCHEMA = 'deposit'
	def SCHEMAVERSION = '1.0' 
	
	@ProxyMethod
	public def getList( searchText, params ) {
		if( ! searchText ) return getListByNamedQuery('deposit:getList', null, params )
		List result = []
		def filter = [ txnno:searchText, depositedbyname:searchText+'%']
		if( (result = getListByNamedQuery('deposit:getListByTxnno', filter, params) ) ) return result 
		if( (result = getListByNamedQuery('deposit:getListByDepositor', filter, params) ) ) return result 
		return result
	}
	
	@ProxyMethod
	public def getFundList(){
		return em.sqlContext.createNamedQuery("deposit:getFundList").resultList;
	}
	
	@ProxyMethod
	public Map createDeposit( cashierid ) {
        def cashier = userSvc.getCashier( cashierid )
		def deposit = [
			objid            : 'D' + new UID(),
			schemaname       : SCHEMA,
			schemaversion    : SCHEMAVERSION,
			docstate         : OPEN_STATE,
			txndate          : dateSvc.format('yyyy-MM-dd', new Date() ),
            depositedbyid    : cashier.objid,
            depositedbyname  : cashier.formalname,
            depositedbytitle : cashier.jobtitle,
			cash             : 0.0,
			noncash          : 0.0,
			amount           : 0.0,
			runningamount    : 0.0,
			noncashpayments  : [], 
			fundsummaries	 : [],
        ]
		
		deposit.liquidations  = getOpenLiquidations()
		if( ! deposit.liquidations ) throw new Exception('There are no open liquidations for deposit.')
		
		deposit.fundtotals 		= getOpenFundTotals()
		deposit.noncashpayments = getOpenNonCashPayments()
		deposit.noncashcount 	= deposit.noncashpayments.size()
		deposit.amount 			= deposit.liquidations.sum({it.amount})
		return deposit 
    }
	
	@ProxyMethod
	public Map open( objid ) {
		return em.read(SCHEMA, [objid:objid] )
	}
	
	@ProxyMethod
	public Map create( deposit ) {
		deposit.dtposted = new Date()
		deposit.txnno = sequenceSvc.getNextFormattedSeries('DEPOSIT')
		validateDeposit( deposit )
		
		deposit.cash = deposit.fundsummaries.sum( {it.cash} )
		deposit.noncash = deposit.fundsummaries.sum( {it.noncash} )
		
		em.create( deposit.schemaname, deposit )
		depositLiquidation( deposit )
		logSvc.log('CREATE', 'Deposit', deposit.objid )
		return deposit
	}
	
	@ProxyMethod
	public def closeDeposit( deposit ) {
		checkClosed( deposit )
		checkValidationInfo( deposit )
		em.validate( deposit.schemaname, deposit ) 
		
		deposit.docstate = CLOSED_STATE
		em.update( deposit.schemaname, deposit )
		logSvc.log('CLOSE', 'Deposit', deposit.objid )
		return deposit
	}
	
	@ProxyMethod
	public def createRCDByFundReport( deposit, fund ) {
		fund = ( fund ? fund.fund : 'GENERAL')
		def data = [
			txnno				: deposit.txnno, 
			txndate				: dateSvc.parse('yyyy-MM-dd', deposit.txndate ),
			collectionsummaries	: getCollectionSummaryByAFAndFund( deposit, fund ),
			remittancedeposits	: buildRemittanceDepositList( deposit, fund  ),
			remittedforms		: [[:],[:]],
			nonserialremittances: [[:],[:]],
			fund 				: fund, 
		]
		data.amount = data.collectionsummaries.amount.sum()
		data.amountinwords = numSvc.convertString( data.amount + "" )
		data.depositedbyname = deposit.depositedbyname
		data.depositedbytitle = deposit.depositedbytitle
		return data 
	}
	
	List buildRemittanceDepositList( deposit, fund  ) {
		def list = []
		
		def cashfundsummaries = deposit.fundsummaries.findAll{ it.bankaccount.fund == fund && it.cash > 0.0 }
		if( cashfundsummaries ) {
			cashfundsummaries.each {
				list.add([
					cashier		: deposit.depositedbyname,
					depositref  : it.bankaccount.bankcode + ' - Cash Deposit D/S _______________ ',
					depositamt  : it.cash ,
				])
			}
		}
		
		def checkfundsummaries = deposit.fundsummaries.findAll{ it.bankaccount.fund == fund && it.noncash > 0.0 }
		if( checkfundsummaries ) {
			checkfundsummaries.each {
				list.add([
					cashier		: deposit.depositedbyname,
					depositref  : it.bankaccount.bankcode + ' - Check Deposit D/S _______________ ',
					depositamt  : it.noncash ,
				])
			}
		}
		return list 
	}
	
	List getCollectionSummaryByAFAndFund( deposit, fund ) {
		return em.sqlContext.createNamedQuery('deposit:getCollectionSummaryByAFAndFund')
					.setParameters([depositid:deposit.objid, fund:fund])
					.resultList
	}
	
	@ProxyMethod
	public List getCheckTypes() {
		return [ 'LOCAL', 'REGIONAL', 'OUT_OF_TOWN', 'ON_USMC', 'OTHER_BANK_MC']
	}
	
	@ProxyMethod
	public List getBankAccountList( fundid ) {
		return em.sqlContext.createNamedQuery('deposit:getBankAccountList')
					.setParameter('fundid', fundid )
					.resultList
	}
	
	void checkClosed( deposit ) {
		if( getState( deposit ) == CLOSED_STATE ) 
			throw new Exception('Deposit has already been closed.')
	}
	
	def getState( deposit ) {
		def data = em.sqlContext.createNamedQuery('deposit:getState').setParameter('objid', deposit.objid ).singleResult 
		if( ! data ) throw new Exception('Deposit does not exists.\nPlease verify that it still exists.')
		return data.docstate 
	}
	
	void checkValidationInfo( deposit ) {
		deposit.fundsummaries.each { summ ->
			required('Validation No.', summ.fundname, summ.validationno)
			required('Validation Date', summ.fundname, summ.validationdate)
		}
	}
	
	void required( caption, fundname, value ) {
		if( ! value  ) 
			throw new Exception(caption + ' is required for Fund ' + fundname + '.')
	}
	
	void depositLiquidation( deposit ) {
		def params = [
			depositid        : deposit.objid,
			dtdeposited		 : deposit.dtposted,
		]
		em.sqlContext.createNamedExecutor('deposit:depositOpenLiquidation').setParameters(params).execute()
		em.sqlContext.createNamedExecutor('deposit:depositOpenLiquidationList').setParameters(params).execute()
	}
	
	void validateDeposit( deposit ) {
		
		validateNonCashSummaries( deposit )
		validateDenominations( deposit )
		
		//fundsummary.amount totals = depositamount
		def totalamt = deposit.fundsummaries.amount.sum() 
		if( !totalamt ) totalamt = 0.0
		if( totalamt != deposit.amount ) throw new Exception('Deposit Summary Total must be equal to Total Deposit.')
		
		
		em.validate( deposit.schemaname, deposit )
	}
	
	void validateDenominations( deposit ) {
		deposit.fundsummaries.each { summ ->
			if( ! summ.denominations ) 
				throw new Exception('Denominations must be specified for Fund ' + summ.fundname )
				
			def total = summ.denominations.sum( {it.amount} )
			if( summ.cash == 0.0 && total != 0.0 )
				throw new Exception('Total Cash Breakdown must be zero since Cash Deposit is zero for Fund ' + summ.fundname )
			if( summ.cash > 0.0 && summ.cash != total )
				throw new Exception('Total Cash Breakdown must be equal to Cash Deposit for Fund ' + summ.fundname )
		}
	}
	
	void validateNonCashSummaries( deposit ) {
		//total number of noncash payments must be less than or equal to total number of noncash breakdowns.
		//total number is possibly less than for cases where outside checks are change using cash from collection
		def computed_noncashcount =  getNonCashPaymentBreakdownCount( deposit )
		if( deposit.noncashcount > computed_noncashcount ) 
			throw new Exception('The number of Non-Cash Payments to be deposited is incorrect.\nThere are at least ' + deposit.noncashcount + ' Non-Cash payments expected.')
		
		deposit.fundsummaries.each {  summ ->
			if( ! summ.noncashpayments ) return 
			
			if( summ.noncash == 0.0 && summ.noncashpayments.size() > 0 ) 
				throw new Exception('Non-Cash Payments must be empty since Non-Cash Deposit is zero for Fund ' + summ.fundname )
			if( summ.noncash > 0.0 && summ.noncashpayments.size() == 0 ) 
				throw new Exception('Non-Cash Payments must be specified since Non-Cash Deposit is greater than zero for Fund ' + summ.fundname  )
				
			def total = summ.noncashpayments.sum( {it.amount} )
			if( summ.noncash != total ) 
				throw new Exception('Non-Cash Deposit amount must be equal to Total Non-Cash Payments amount for Fund ' + summ.fundname )
		}
	}
	
	//return the total noncash count by adding the sizes of each fundsummaries
	def getNonCashPaymentBreakdownCount( deposit ) {
		def count = 0
		deposit.fundsummaries.each { summ ->
			if( summ.noncashpayments ) {
				count += summ.noncashpayments.size()
			}
		}
		return count
	}
	
	
	List getOpenLiquidations() {
		return em.sqlContext.createNamedQuery('deposit:getOpenLiquidations').resultList 
	}
	
	List getOpenFundSummaries() {
		return em.sqlContext.createNamedQuery('deposit:getOpenFundSummaries').resultList 	
	}
	
	List getOpenFundTotals() {
		return em.sqlContext.createNamedQuery('deposit:getOpenFundTotals').resultList 	
	}
	
	List getOpenNonCashPayments() {
		return em.sqlContext.createNamedQuery('deposit:getOpenNonCashPayments').resultList 	
	}
	
	List getListByNamedQuery(namedQuery, criteria, params ) {
		if( ! params ) params = [ _start:0, _limit:50]
		return em.sqlContext.createNamedQuery( namedQuery )
					.setParameters(criteria)
					.setFirstResult( params._start )
					.setMaxResults( params._limit ) 
					.resultList 
	}
}


