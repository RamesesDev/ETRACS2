import com.rameses.annotations.*
import com.rameses.common.*
import java.rmi.server.UID

class BPApplicationService{
	
	@Service("TxnReference")
	def txnSvc;
	
	@Service('DateService')
	def dateService;
	
	@Service('BPRuleService')
	def ruleSvc;
	
	def BP_RECIVABLE_SCHAMENAME = 'bpledger:bpreceivable';
	def BUSINESS_SCHEMA = 'business:business';
	
	def SCHEMANAME = 'bpapplication:bpapplication';
	def SCHEMAVERSION = '1.0';
	
	@Service('SequenceService')
	def sequenceSvc;
	
	@PersistenceContext('main')
	def em;

	private def format( def date, def format ){
		def sdf = new java.text.SimpleDateFormat( format );
		if( date instanceof Date ) return sdf.format( date );
		return sdf.parse( date );
	}
	
	@ProxyMethod
	public def save( def application ){
		if( application.txndate && application.txnmode == 'CAPTURE' ){
			application.txndate = format( application.txndate, 'yyyy-MM-dd');
			application.iyear = format( application.txndate, 'yyyy' );
		}
		
		if( application.txnmode == 'ONLINE' ){
			application.txndate = dateService.serverDate;
			application.iyear = format( application.txndate, 'yyyy' );
		}
	
		if( !application.info.lobs ) throw new Exception("There must be at least 1 line of business.");
		if( application.txnmode == 'ONLINE' ){
			if( application.txntype == 'RENEW' ) {
				if( !application.info.lobs.findAll{ it.assessmenttype == 'RENEW'; } ) throw new Exception("There must be at least 1 line of business that is RENEW.");
			}
			
			if( application.txntype == 'RETIRE' ){
				if( !application.info.lobs.findAll{ it.assessmenttype == 'RETIRE_LINE'; } ) throw new Exception("There must be at least 1 line of business that is RETIRE_LINE.");
			}
			
			if( application.txntype == 'ADDLOB' ){
				if( !application.info.lobs.findAll{ it.assessmenttype == 'NEW'; } ) throw new Exception("There must be at least 1 line of business that is NEW.");
			}
		}
		
		if( !application.objid ) return createBPApp( application );
		else return update( application );
	}
	
	def createBPApp( def application ){
		application.objid = 'BP'+new UID();
		application.schemaname = SCHEMANAME;
		application.schemaversion = SCHEMAVERSION;
		application.tradename = application.info.tradename;
		application.businessaddress = application.info.businessaddress;
		application.txnno = getNextSeries();
		
		if( application.businesid ) {
			txnSvc.insert( em, businesid, application.objid, 'BPApplication', 'Unable to process transaction. \n business is currently reference by a ' + application.txntype + ' transaction');
		}
		
		em.validate( SCHEMANAME, application );
		em.create( SCHEMANAME, application );
		return application;
	}
	
	private void insertForlateRenewal( def application ){
		if( application.businessid ){
			def currentyear = Integer.parse( format( dateService.serverDate, 'yyyy' ) );
			def prevyear = currentyear - 1;
			
			def oldapp = em.createNamedQuery( 'bpapplication.getApplicationByBusinessId' )
						   .setParameters([objid:application.businessid])
						   .singleResult;

			if( oldapp.iyear < prevyear ){
				for( int i=oldapp.iyear; i <= prevyear; i++){
					def app = clone( oldapp );
					app.txxno = application.txnno + '-' + i;
					app.iyear = i;
					app.taxfees = [];
				}
			}
		}
	}
	
	private def clone( def obj ){
		if( obj instanceof Map ){
			def copy = [:];
			obj.each{ k, v -> copy.put( k, clone( v ) ); }
			return copy;
		}
		
		if( obj instanceof List ){
			def copy = [];
			obj.each{ copy.add( clone( it ) ); }
		}
		return obj;
	}
	
	@ProxyMethod
	public def update( def application ){
		em.validate( SCHEMANAME, application );
		em.update( SCHEMANAME, application );
		return application;
	}
	
	private def getNextSeries(){
		def year = new java.text.SimpleDateFormat('yyyy').format( new Date() );
		def prefix = 'BP-'+year;
		return prefix + sequenceSvc.getNextFormattedSeriesA( 'BP'+year, 5 );
	}
	
	@ProxyMethod
	public def open( def objid ){
		def application = em.read( SCHEMANAME, [objid: objid] );
		if( !application ) throw new Exception("Application document no longer exist.");
		return application;
	}
	
	@ProxyMethod
	public def getList(def searchText, def param){
		return em.sqlContext.createNamedQuery('bpapplication:getList')
				 .resultList;
	}
	
	@ProxyMethod
	public def evaluateTxnType(def application){

		def txndate = dateService.serverDate;
		application.txndate = format( txndate, 'yyyy-MM-dd' );
		application.iyear = format( txndate, 'yyyy' );
		
		if( application.txntype == 'NEW' || application.txnmode == 'CAPTURE' ) return application;
		if( application.txntype == 'ADDLOB' ) return evaluateAddLob( application );
		if( application.txntype == 'RENEW' ) return evaluateRenew( application );
		if( application.txntype == 'LATE_RENEWAL' ) return evaluateRenew( application );
		if( application.txntype == 'RETIRE' ) return evaluateRetire( application );
		if( application.txntype == 'RETIRELINE') return evaluateRetire( application );
		
		throw new Exception( 'Transaction for '+ application.txnno +' not supported.');
	}
	
	@ProxyMethod
	public def submitForAssessment( def applicationid ) {
		def app = open( applicationid );
		if( app.docstate != 'DRAFT' ) throw new Exception("Only DRAFT application can be submit for assessment.");

		app.info.appinfos = ruleSvc.buildInfos( createAppEntity( app ) ).infos;
		em.sqlContext.createNamedQuery('bpapplication:getApplicationByParentId')
		.setParameters([parentid: applicationid])

		.resultList.each{
			it.info = em.serializer.read( it.info );
			it.info.appinfos = ruleSvc.buildInfos( createAppEntity( it ) ).infos;
			em.update( SCHEMANAME, it );
		}
		
		app.docstate = 'FOR_ASSESSMENT';
		em.update( SCHEMANAME, app );
		
		return app;
	}
	
	@ProxyMethod
	public def evaluateApplicationInfo( def application ){
		def app = createAppEntity( open( application.objid ) );
		app.infos = application.infos;
		checkValueType( app.infos );
		application.infos = ruleSvc.buildInfos( app ).infos;
		return application;
	}
	
	private def createAppEntity( def application ){
		def app = [
			objid: application.objid,
			organization: application.info.organization,
			applicationtype: application.txntype,
			officetype: application.info.officetype,
			barangayid: application.info.barangay.barangayid,
			lobs : [],
			taxfees: [],
			infos:[]
		];

		application.info.lobs.each{
			if( it.assessmenttype != 'ACTIVE' ){
				app.lobs.add( [ lob: [classificationid: it.classificationid, objid: it.lobid, name: it.name],
					assessmenttype: it.assessmenttype
				]);
			}
		}
		return app;
	}
	
	@ProxyMethod
	public List getApplicationTypes() {
		return ['NEW', 'RENEW', 'RETIRE', 'ADDLOB', 'RETIRELOB', 'UPDATENEW']
	}
	
	@ProxyMethod
	public List getOrganizationTypes() {
		return ['SINGLEPROPRIETORSHIP','PARTNERSHIP','CORPORATION','COOPERATIVE','ASSOCIATION','ESTATE','INCORPORATED']
	}
	
	@ProxyMethod
	public List getOfficeTypes() {
		return ['MAIN','BRANCH']
	}
	
	@ProxyMethod
	public def getApplicationList( def applicationid ){
		def app = open( applicationid );
		def applist = [];
		applist.add( evaluateApplication( app ) );
		
		em.sqlContext.createNamedQuery( 'bpapplication:getApplicationByParentId' )
		  .setParameters( [parentid: app.objid] )
		  .resultList.each{ 
			it.info = em.serializer.read( it.info );
			applist.add( evaluateApplication( it ) ) ;
		};
		
		return applist;
	}
	
	private def evaluateApplication( def application ){
		def app = [:];
		app.objid = application.objid;
		app.txnno = application.txnno;
		app.iyear = application.iyear;
		app.txntype = application.txntype;
		app.infos = application.info.appinfos;
		app.taxfees = application.info.taxfees;
		app.assessedvalue = 0.0;
		app.amountdue = 0.0;
		
		app.taxfees.each{
			app.assessedvalue += it.assessedvalue;
			app.amountdue += it.amountdue;
		}
		
		return app;
	}
	
	@ProxyMethod
	public def evaluateTaxesAndFees( def parentid, def list ){
		list.each{ it ->
			def application = open( it.objid );
			def app = createAppEntity( application );
			
			app.infos.clear();
			app.infos.taxfees.clear();

			app.infos = it.infos.findAll{ it.requiredbeforeprint == false };
			app.taxfees = [];
			
			checkValueType( app.infos );
			def res = ruleSvc.buildTaxFees( app );
			
			application.info.taxfees = res.taxfees;
			application.info.appinfos = it.infos;
			
			if( parentid == it.objid ){
				if( application.docstate == 'FOR_ASSESSMENT' ) 
					application.docstate = 'FOR_REVIEW';
			}

			update( application );
		}
		
		return open( parentid );
	}
	
	void checkValueType( def infos ){;}
	
	@ProxyMethod
	public List getAccountSummaryTypes() {
		return [
			[ objid:'BUSINESS_TAX', name:'TOTAL_BUSINESS_TAX' ],
			[ objid:'REG_FEE', name:'TOTAL_REGULATORY_FEE' ],
			[ objid:'OTHER_FEE', name:'TOTAL_OTHER_FEE' ],
		]
	}
	
	@ProxyMethod
	public def disapproveApplication( def applicationid ){
		def app = open( applicationid );
		app.docstate = 'FOR_REVIEW';
		em.update( SCHEMANAME, app ) ;
		return app;
	}
	
	@ProxyMethod
	public def submitForReview( def appid, def applist ){
		applist.each{
			def app = open( it.objid );
			app.info.taxfees = it.taxfees;
			println app.info.taxfees;
			if( app.objid == appid ) app.docstate = 'FOR_APPROVAL';
			em.update(  SCHEMANAME, app );
		}
		return open( appid );
	}
	
	@ProxyMethod
	public def cancelApplicationForAssessement( def appid ){
		def app = open( appid );
		em.sqlContext.createNamedExecutor('bpapplication:deleteReferenceApplication')
		  .setParameters([parentid: appid])
		  .execute();
		
		app.docstate = 'DRAFT';
		app.info.appinfos = [];
		app.info.taxfees = [];
		
		em.update( SCHEMANAME, app );
		return app;
	}
	
	@ProxyMethod
	public def approveApplication( def appid, def applist ){
		def app = open( appid );
		if( app.docstate == 'APPROVED' ) throw new Exception('Application is already APPROVED.');
		submitForReview( appid, applist );
		app.docstate = 'APPROVED';
		
		def business = getBusiness( app );
		business.applicationid = app.objid;
		business.docstate = 'FOR_RELEASE';
		createBPReceivable( business , applist );
		
		if( app.txnmode == 'ONLINE' && app.txntype.matches( 'RENEW|LATE_RENEWAL' ) ){
			updatePreviousApplication( business.objid );
		}
		
		if( app.txntype.matches('RETIRE') ){
			def lobs = app.info.lobs.findAll{ it.assessmenttype == 'RETIRE_LINE' };
			if( lobs.size() == app.info.lobs.size() ) business.docstate = 'RETIRED';
			else app.docstate = 'RETIRE_LINE';
		}
		
		txnSvc.remove( em, business.objid );
		txnSvc.insert( em, business.objid, application.objid, 'BPApplication', 'Unable to process transaction. \n business is currently reference by a ' + application.txntype +' transaction' );
		
		app.businessid = business.objid;
		em.update( BUSINESS_SCHEMA, business );
		em.update( SCHEMANAME, app );
		
		return app;
	}
	
	def getAmount( def a, def b, def amount ){
		def val = new BigDecimal(amount).divide( new BigDecimal(b), 2, BigDecimal.ROUND_HALF_UP)
		if( a == b ) return new BigDecimal(amount) - (val * ( new BigDecimal(b) - 1)) ;
		return val;
	}

	void saveReceivable( def qtr, def businessid, def app, def it ){
		def brc = [
			objid: 'BPRC' + new UID(),
			businessid: businessid,
			applicationid: app.objid,
			applicationtype: app.txntype,
			appno: app.txnno,
			iyear: app.iyear,
			iqtr: qtr,
			lobid: it.lobid,
			lobname: it.lobname,
			acctid: it.acctid,
			acctno: it.acctno,
			accttitle: it.accttitle,
			amount: getAmount( qtr , 4 , it.amountdue ),
			amtpaid: 0.0
		];
		em.create( BP_RECIVABLE_SCHAMENAME, brc );
	}
	
	void createBPReceivable( def business, def applist ){
		applist.each{ a ->
			def app = open( a.objid );
			app.info.taxfees.each{
				for( int i=1; i <= 4; i++ ){
					if( it.amountdue > 0 ){
						saveReceivable( i, business.objid, app, it );
					}
				}
			}
		}
	}
	
	def getBusiness( def app){
		if( app.businessid ) return em.read( BUSINESS_SCHEMA, [objid:app.businessid] );
		def business = [
			objid: 'BUS'+ new UID(),
			schemaname: BUSINESS_SCHEMA,
			schemaversion: '1.0',
			docstate: 'ACTIVE',
			taxpayerid: app.info.taxpayerid,
			taxpayername: app.info.taxpayername,
			taxpayeraddress: app.info.taxpayeraddress,
			yearstated: app.iyear,
			dtregistered: app.txndate,
			sec: app.info.sec,
			dti: app.info.dti,
			sss: app.info.sss,
			tin: app.info.tin,
			pin: app.info.pin,
			applicationid: app.objid,
			tradename: app.info.tradename,
			businessaddress: app.info.businessaddress,
			adminname: app.info.administratorname,
			adminaddress: app.info.administratoraddress,
			organization: app.info.organization,
			officetype: app.info.officetype
		];
		em.create( BUSINESS_SCHEMA,  business );
		return business;
	}
	
	void updatePreviousApplication( def busineid ){
		def b = em.read( BUSINESS_SCHEMA, [objid:businessid] );
		def app = em.read( SCHEMANAME, b.applicationid );
		app.docstate = 'RENEWED';
		em.update( SCHEMANAME, app );
	}
	
	def evaluateAddLob( def application ){
		def bp = em.read( 'business:business', [objid:application.businessid] );
		
		if( bp.docstate != 'ACTIVE' ) throw new Exception('Only active business can add line.');
		
		def prevapp = open( bp.applicationid );

		application.taxpayerid = prevapp.taxpayerid;
		application.taxpayername = prevapp.taxpayername;
		application.tradename = prevapp.tradename;
		application.businessaddress = prevapp.businessaddress;
		application.parentid = prevapp.objid;
		
		application.info = prevapp.info;
		application.info.taxfees = [];
		application.info.appinfos = [];
		application.info.lobs.each{ it.assessmenttype = 'ACTIVE'; }
		
		return application;
	}
	
	def evaluateRenew( def application ){
		def bp = em.read( 'business:business', [objid:application.businessid] );
		if( bp.docstate != 'EXPIRED' ) throw new Exception('Only expired business can be renewed.');
		def prevapp = open( bp.applicationid );
		
		application.taxpayerid = prevapp.taxpayerid;
		application.taxpayername = prevapp.taxpayername;
		application.tradename = prevapp.tradename;
		application.businessaddress = prevapp.businessaddress;
		application.parentid = prevapp.objid;
		
		application.info = prevapp.info;
		application.info.taxfees = [];
		application.info.appinfos = [];
		application.info.lobs.each{ it.assessmenttype = 'RENEW'; }
		
		return application;
	}
	
	def evaluateRetire( def application ){
		def bp = em.read( 'business:business', [objid:application.businessid] );
		def prevapp = open( bp.applicationid );
		
		application.taxpayerid = prevapp.taxpayerid;
		application.taxpayername = prevapp.taxpayername;
		application.tradename = prevapp.tradename;
		application.businessaddress = prevapp.businessaddress;
		application.parentid = prevapp.objid;
		
		application.info = prevapp.info;
		application.info.taxfees = [];
		application.info.appinfos = [];
		application.info.lobs.each{ it.assessmenttype = 'ACTIVE';}
		
		return application;
	}
	
	@ProxyMethod
	public def lookupBusiness( def searchText ){
	
		def fetch = { list, qry, param ->
			list.clear();
			def q = em.sqlContext.createNamedQuery(qry);
			if( param ) q.setParameter('searchText', param );
			list.addAll( q.setMaxResults(10).resultList );
			return list;
		}
		
		def list = [];
		if( !searchText ) return fetch(list, 'lookupbp:lookupBusiness', '' );
		if( fetch( list, 'lookupbp:lookupBusinessByBIN', searchText ) ) return list;
		if( fetch( list, 'lookupbp:lookupBusinessByAppNo', searchText ) ) return list;
		if( fetch( list, 'lookupbp:lookupBusinessByPermitNo', searchText ) ) return list;
		if( fetch( list, 'lookupbp:lookupBusinessByTradeName' , searchText + '%') ) return list;
		if( fetch( list, 'lookupbp:lookupBusinessByTaxpayerName',searchText + '%') ) return list;
		if( fetch( list, 'lookupbp:lookupBusinessAdminstratorName', searchText  + '%') ) return list;
		if( fetch( list, 'lookupbp:lookupBusinessBusinessAddress', searchText +'%' ) ) return list;
		return list;
	}
	
	@ProxyMethod
	public void delete( def applicationid ){
		def app = open( applicationid );
		if( app.businessid ) txnSvc.delete( em, app.businessid );
		em.delete( SCHEMANAME, app );
	}
	
}