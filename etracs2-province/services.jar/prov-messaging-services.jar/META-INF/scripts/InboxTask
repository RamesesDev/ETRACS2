import com.rameses.annotations.*
import com.rameses.common.*

/*
* Periodically reads sys_inbox for messages. When messages are available,
* it dispatches the message by calling MessageService.onreceive
* and move the message from inbox to processedinbox 
*
*/
class InboxTask
{
    @PersistenceContext('main')
    def em 
    
    @Service('MessageService')
    def msgSvc
	
	def INBOX_SCHEMA = 'message:inbox'
	def PROCESSEDINBOX_SCHEMA = 'message:processedinbox'
	
	@ProxyMethod
	public def processMessage( task ) {
		def msglist = getInboxMessages()
        if( msglist )  {
			msglist.each{ msg -> 
        		try {
					msg = em.read( INBOX_SCHEMA, msg)
					println 'Processing inbox message[' + msg.action + ']'
					msgSvc.onreceive( msg )
					moveMessageToProcessedInbox( msg )
				}
				catch( e ) {
					e.printStackTrace()
					logMessage( msg, e.message )
				}	
			}
        }
		else {
			println 'Inbox is empty...'
		}
        return true
	}
	
	void logMessage( msg, errorMsg ) {
        msg.message = [date:new Date(), msg:errorMsg]
        em.update( msg.schemaname, msg )
    }
    
    def getInboxMessages() {
        return em.sqlContext.createNamedQuery('message:getInboxMessageId').resultList
    }
    		
	void moveMessageToProcessedInbox( msg ) {
		em.create(PROCESSEDINBOX_SCHEMA, msg )
		em.delete(INBOX_SCHEMA, msg )
	}
}