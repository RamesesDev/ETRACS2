import com.rameses.annotations.*;
import java.rmi.server.UID;

class FAASService
{
	@PersistenceContext("java:system")
	def em_sys;
	
	@PersistenceContext("etracs")
	def em;
	
	@Env
	def env;
	
	@Service("DateService")
	def dateService;

	@Service("Var")
	def var;

	@Service("TDService")
	def tdService;
	
	@Service("SequenceService")
	def seqService;

	def PROVAPPROVAL_STATE = "PROVAPPROVAL";
	def FORAPPROVAL_STATE = "FORAPPROVAL";
	def CURRENT_STATE = "CURRENT";
	def DISAPPROVED_STATE = "DISAPPROVED";
	def CANCELLED_STATE = "CANCELLED";
	
	@ProxyMethod
	public def getList( search, params ) {
		if( env.ASSIGNED_LGU && env.ASSIGNED_LGU.size() > 0) {
			return getListByAssignedLgu( search, params );
		}
		return getListAll( search, params );
	}
	
	@ProxyMethod
	public def getListAll( search, params ) {
		def result = null;
		def state = search.state;
		def textSearch = search.textSearch;
		if( ! textSearch ) return getListByName("faas:findByState", [state:state], params);
		if( (result = getListByName("faas:findByTdNo", [state:state, tdno:textSearch], params)) ) return result;
		if( (result = getListByName("faas:findByTaxpayerName", [state:state, taxpayername:textSearch], params)) ) return result;
		if( (result = getListByName("faas:findByPin", [state:state, pin:textSearch], params)) ) return result;
		if( (result = getListByName("faas:findByBarangay", [state:state, barangay:textSearch], params)) ) return result;
		if( (result = getListByName("faas:findByCadastralLotNo", [state:state, cadastrallotno:textSearch], params)) ) return result;
		if( (result = getListByName("faas:findBySurveyNo", [state:state, surveyno:textSearch], params)) ) return result;
		if( (result = getListByName("faas:findByBlockNo", [state:state, blockno:textSearch], params)) ) return result;
		return result;
	}
	
	@ProxyMethod
	public def getListByAssignedLgu( search, params ) {
		def state = search.state;
		def textSearch = search.textSearch;
		def assignedLgus = env.ASSIGNED_LGU;
		def len = assignedLgus.size;
		def whereClause = "";
		
		def vars = '';
		vars = '?,'.multiply( len )[0..(len*2)-2];
		
		def values = assignedLgus;
		if( ! textSearch ) {
			values.add( state );
			whereClause = " WHERE municipality in ($vars) AND state = ? ORDER BY pin ";
			return getListByVars("faas:findByExaminer",["whereClause":whereClause], values, params );
		}
		
		values = assignedLgus;
		values.add( textSearch );
		values.add( state );
		def result = null;		
		
		whereClause = " WHERE municipality in ($vars) AND tdno = ? AND state = ? ORDER BY pin ";
		if( (result = getListByVars("faas:findByExaminer",["whereClause":whereClause], values, params )) ) return result;
		
		whereClause = " WHERE municipality in ($vars) AND taxpayername LIKE ? AND state = ? ORDER BY pin ";
		if( (result = getListByVars("faas:findByExaminer",["whereClause":whereClause], values, params )) ) return result;
		
		whereClause = " WHERE municipality in ($vars) AND pin LIKE ? AND state = ? ORDER BY pin ";
		if( (result = getListByVars("faas:findByExaminer",["whereClause":whereClause], values, params )) ) return result;
		
		whereClause = " WHERE municipality in ($vars) AND barangay = ? AND state = ? ORDER BY pin ";
		if( (result = getListByVars("faas:findByExaminer",["whereClause":whereClause], values, params )) ) return result;
		
		whereClause = " WHERE municipality in ($vars) AND cadastrallotno = ? AND state = ? ORDER BY pin ";
		if( (result = getListByVars("faas:findByExaminer",["whereClause":whereClause], values, params )) ) return result;
		
		whereClause = " WHERE municipality in ($vars) AND surveyno = ? AND state = ? ORDER BY pin ";
		if( (result = getListByVars("faas:findByExaminer",["whereClause":whereClause], values, params )) ) return result;
		
		whereClause = " WHERE municipality in ($vars) AND blockno = ? AND state = ? ORDER BY pin ";
		if( (result = getListByVars("faas:findByExaminer",["whereClause":whereClause], values, params )) ) return result;
		
		return result;
	}
	
	@ProxyMethod
	public def create( @Param(schema="faas:faas") faas ) {
		faas.sys_dtCreated = dateService.getServerDate();
		em.create("faas:faas",  faas);
		def list = em.indexer.getIndexFor("faas:faas");
		em.indexer.fire( list, faas );
		return faas;
	}
	
	@ProxyMethod
	public def createDisapproved( @Param(schema="faas:faas") faas ) {
		def oid = 'F' + new UID();
		faas.oid = oid;
		em.create("faas:disapproved-faas", faas);
		def list = em.indexer.getIndexFor("faas:faas");
		em.indexer.fire( list, faas );
		def faasInfo = em.read("faas:faas-list", faas);
		faasInfo.oid = oid;
		em.create("faas:faas-disapproved", faasInfo);
		em.delete("faas:faas-list", faasInfo);
		return faas;
	}
	
	@ProxyMethod
	public def open( faasId ) {
		def faas = em.read("faas:faas", [objid:faasId]);
		if( !faas ) throw new Exception("FAAS not found.");
		return faas;
	}
	
	@ProxyMethod
	public def assignPin( faas, key, section, newSeries, oldSeries ) {
		if( faas.rpu.info.type != 'LAND') throw new Exception("Only Land RPU could be assigned a new PIN.");

		checkExists( faas.objid );
		
		validateParcelSeries( key, newSeries, oldSeries ) 
		def sectionNo = buildSectionNo( section );
		def parcelNo = buildParcelNo( newSeries );
		def pin = key + '-' + parcelNo;
		checkDuplicatePin( pin, faas.rp.info.claimNo );
		
		faas.rpu.info.oldPin = faas.rpu.info.pin;
		faas.rp.info.pin = pin;
		faas.rp.info.sectionNo = sectionNo;
		faas.rp.info.parcelNo = parcelNo
		faas.rpu.info.pin = pin;
		em.update( "faas:faas", faas );
		
		def faasInfo = em.read("faas:faas-list", faas);
		faasInfo.pin = pin;
		em.update("faas:faas-list", faasInfo)
		return faas;
	}
	
	@ProxyMethod
	public def exchangePin( fromFaasId, toFaasId ) {
		def fromFaas = open( fromFaasId );
		def toFaas = open( toFaasId );
		
		if( fromFaas.rpu.info.type != 'LAND') throw new Exception("Only Land RPU could be assigned a new PIN.");
		if( fromFaas.state != FORAPPROVAL_STATE ) throw new Exception("RPU $fromFaas.rpu.info.pin is $fromFaas.state. Only for approval state is allowed. ");
		if( toFaas.state != FORAPPROVAL_STATE ) throw new Exception("RPU $toFaas.rpu.info.pin is $toFaas.state. Only for approval state is allowed. ");
		
		/* preserve fromFaas Pin Info */
		def fromPin = fromFaas.rp.info.pin;
		def fromSectionNo = fromFaas.rp.info.sectionNo;
		def fromParcelNo = fromFaas.rp.info.parcelNo;
		/* exchange pin info */
		updatePinInfo( fromFaas , toFaas.rp.info.pin, toFaas.rp.info.sectionNo, toFaas.rp.info.parcelNo );
		updatePinInfo( toFaas , fromPin, fromSectionNo, fromParcelNo );
		/* set oldPin used by logging */
		fromFaas.oldPin = fromPin;
		return fromFaas;
	}
	
	private void updatePinInfo( faas, newPin, newSectionNo, newParcelNo ) {
		faas.rp.info.pin = newPin;
		faas.rp.info.sectionNo = newSectionNo;
		faas.rp.info.parcelNo = newParcelNo;
		faas.rpu.info.pin = newPin;
		em.update("faas:faas", faas);
		
		def faasInfo = em.read('faas:faas-list', faas);
		faasInfo.pin = newPin;
		em.update("faas:faas-list", faasInfo);
	}
	
	@ProxyMethod
	public def getExchangePinList( faasId ) {
		/* return FORAPPROVAL faas excluding this faasId */
		return em.sqlContext.createNamedQuery("faas:getExchangePinList").setParameter("objid", faasId).resultList;
	}
	
	private void checkExists( faasId ) {
		def data = em.sqlContext.createNamedQuery("faas:getState").setParameter("objid", faasId).singleResult;
		if( ! data ) throw new Exception("FAAS not found.");
	}
	
	@ProxyMethod
	public def submit( faasId ) {
		def faas = open( faasId );
		if( faas.state != PROVAPPROVAL_STATE ) throw new Exception("FAAS is already $faas.state.");
		
		def currDate = dateService.getServerDate();
		faas.state  = FORAPPROVAL_STATE;
		faas.info.reviewedBy  = [name:env.USERNAME, title:env.JOBTITLE, dtSigned:currDate];
		em.update( "faas:faas", faas );
		
		def faasData = em.read("faas:faas-list", [ objid:faasId ]);
		if( !faasData ) throw new Exception("FAAS not found.");
		faasData.state = FORAPPROVAL_STATE;
		faasData.reviewedBy = env.USERNAME;
		faasData.reviewedByPosition = env.JOBTITLE;
		em.update("faas:faas-list", faasData);
		return faas;
	}

	@ProxyMethod
	public def returnDoc( faasId, remarks ) {
		def faas = open( faasId );
		if( faas.state == CURRENT_STATE ) throw new Exception("FAAS is already $faas.state.");
		
		def currDate = dateService.getServerDate();
		faas.state = PROVAPPROVAL_STATE;
		faas.remarks = remarks;
		faas.info.reviewedBy  = [name:env.USERNAME, title:env.JOBTITLE, dtSigned:currDate];
		em.update( "faas:faas", faas );
		
		def faasData = em.read("faas:faas-list", [ objid:faasId ]);
		if( !faasData ) throw new Exception("FAAS not found.");
		faasData.state = PROVAPPROVAL_STATE;
		em.update("faas:faas-list", faasData);
		return faas;
	}
	
	@ProxyMethod
	public def approve( faasId ) {
		def faas = open( faasId );
		if( faas.state != FORAPPROVAL_STATE) throw new Exception("FAAS is already $faas.state.");
		
		def faasData = em.read("faas:faas-list", [ objid:faasId ]);
		if( !faasData ) throw new Exception("FAAS not found.");
		
		def newTdNo = tdService.getNextTDNo( faasData ); 
		tdService.checkDuplicateTdNo( newTdNo );
		
		faasData.state = CURRENT_STATE;
		faasData.tdNo  = newTdNo;
		em.update("faas:faas-list", faasData);
		
		def currDate = dateService.getServerDate();
		faas.state = CURRENT_STATE;
		faas.tdNo  = newTdNo;
		faas.info.tdNo = newTdNo;
		faas.info.issueDate = dateService.format('yyyy-MM-dd', currDate);
		faas.info.approvedBy.dtSigned = currDate;
		faas.sys_dtApproved = currDate;
		faas.remarks = null;
		faas.provincialAssessor = var.provincialAssessor.name;
		faas.provincialAssessor = var.provincialAssessor.title
		
		cancelPreviousTds( faas );
		
		em.update( "faas:faas", faas );
		return faas;
	}
	
	@ProxyMethod
	public def disapprove( faasId, remarks )  {
		def faas = open( faasId );
		if( faas.state == CURRENT_STATE ) throw new Exception("FAAS is already $faas.state.");
		
		def currDate = dateService.getServerDate();
		faas.state = DISAPPROVED_STATE;
		faas.remarks = remarks;
		faas.sys_dtCreated = currDate;
		faas.sys_dtApproved = currDate;
		faas.info.reviewedBy  = [name:env.USERNAME, title:env.JOBTITLE, dtSigned:currDate];
		
		def oid = 'F' + new UID();
		faas.oid = oid;
		em.create("faas:disapproved-faas", faas);
		em.delete("faas:faas", faas);
		
		def faasInfo = em.read("faas:faas-list", faas );		
		if( !faasInfo) throw new Exception("FAAS not found.");
		faasInfo.oid = oid;
		em.create("faas:faas-disapproved", faasInfo );
		em.delete("faas:faas-list", faasInfo );
		return faas;
	}
	
	private def getListByName( namedQuery, criteria, params ) {
		return em.sqlContext.createNamedQuery( namedQuery )
						.setParameters( criteria )
						.setFirstResult( params._start )
						.setMaxResults( params._limit )
						.resultList;
	}
	
	private def getListByVars( namedQuery, vars, values, params ) {
		return em.sqlContext.createNamedQuery(namedQuery).setVars(vars).setParameters(values)
						.setFirstResult( params._start )
						.setMaxResults( params._limit )
						.resultList;
	}
	
	private void cancelPreviousTds( faas ) {
		faas.previousFaasIds.each { item ->
			def prevFaas = em.read("faas:faas", [objid:item.faasId]);
			if( prevFaas ) {
				prevFaas.state = CANCELLED_STATE;
				prevFaas.info.cancelInfo = [cancelReason:faas.info.txnType, cancelDate:faas.sys_dtApproved, cancelledByTdNo:faas.tdNo];
				em.update("faas:faas", prevFaas);
			}
		}
	}
	
	private def buildSectionNo( section )  {
		def sectionLen = Integer.parseInt( var.section_index_len );
		return section.toString().padLeft(sectionLen, '0')
	}
	
	private def buildParcelNo( newSeries ) {
		def parcelLen = Integer.parseInt( var.parcel_index_len );
		return newSeries.toString().padLeft( parcelLen,'0');
	}
	
	private void checkDuplicatePin( pin, claimNo ) {
		def data = em.sqlContext.createNamedQuery("faas:getPinCount").setParameter("pin", pin).singleResult;
		if( data && data.pinCount > 0 ) {
			throw new Exception("Duplicate PIN exists.");
		}
	}
	
	private void validateParcelSeries( key, newSeries, oldSeries) {
		def seq = em_sys.sqlContext.createNamedQuery("sequence:getCurrentSeries").setParameter("objid",key).singleResult;
		if( seq && oldSeries != seq.currentSeries ) throw new Exception("Current Series has been modified. Please try again.");
		if( seq && seq.currentSeries > newSeries) throw new Exception("New Series $newSeries must be greater than or equal to $seq.currentSeries");
		seqService.updateNextSeries( key, newSeries+1);
	}
	
}
