import com.rameses.annotations.*;

class TDService
{
	@PersistenceContext("etracs")
	def em;

	@Service("SequenceService")
	def sequenceService;
	
	@Service("Var")
	def var;

	@ProxyMethod
	public def getNextTDNo( faasInfo ) {
		def ry = faasInfo.ry;
		def provinceCityIndex  = faasInfo.provinceCityIndex;
		def municipalityIndex = faasInfo.municipalityIndex;
		def barangayIndex = faasInfo.barangayIndex;
		
		def tdkey = var.td_format;
		tdkey = tdkey.replace('Y', ry as String);
		if( provinceCityIndex ) {
			tdkey = tdkey.replace('P', provinceCityIndex);
			tdkey = tdkey.replace('C', provinceCityIndex);
		}
		tdkey = tdkey.replace('M', municipalityIndex);
		tdkey = tdkey.replace('B', barangayIndex);
		def parcelNo = sequenceService.getNextFormattedSeries( tdkey );
		
		if( var.td_format.contains( '-') ) 
			return tdkey + '-' + parcelNo
		return tdkey + parcelNo;
	}
	
	@ProxyMethod
	public void checkDuplicateTdNo( tdNo ) {
		def faas = em.sqlContext.createNamedQuery("faas:getByTdNo").setParameter("tdNo", tdNo).singleResult;
		if( faas ) throw new Exception("Duplicate TD No. $tdNo exists.");
	}
	

	@ProxyMethod
	public def openFaas( faasId ) {
		def faas = em.read("faas:faas", [objid:faasId]);
		if( !faas ) throw new Exception("FAAS not found.");
		return faas;
	}

	@ProxyMethod
	public def open( def objid ){
		return em.read("td:td", [objid: objid] );
	}

	@ProxyMethod
	public def openByTdNo( def tdNo ){
		def td = em.sqlContext.createNamedQuery("td:getIdByTdNo")
		           .setParameters([tdNo:tdNo])
				   .singleResult;
		if( !td ) throw new Exception("Tax Declaration not found.");
		return open( td.objid );
	}
	
	@ProxyMethod
	public void post( def faas ) {
		def td = [
			objid         : faas.objid,
			schemaName    : "td:td",
			schemaVersion : "1.0",
			state         : faas.state,
			tdNo          : faas.info.tdNo,
			pin           : faas.rpu.info.pin,
			info          : buildInfo( faas ),
			assessments   : buildAssessment( faas ),
		];
		
		em.validate("td:td", td );
		em.create("td:td", td );
	}
	
	private def buildInfo( faas ) {
		def info = faas.info;
		def rp   = faas.rp.info;
		def rpu  = faas.rpu.info;
		
		return [
			tdNo            : faas.tdNo,
			txnType         : info.txnType,
			issueDate       : info.issueDate,
			effectivityYear : info.effectivityYear,
			effectivityQtr  : info.effectivityQtr,
			titleNo         : info.titleNo,
			titleDate       : info.titleDate,
			titleType       : info.titleType,
			prevTdNo        : info.prevTdNo,
			prevPin         : info.prevPin,
			prevOwner       : info.prevOwner,
			prevAssessedValue : info.prevAssessedValue,
			prevMarketValue   : info.prevMarketValue,
			cancelReason      : info.cancelReason,
			cancelDate        : info.cancelDate,
			cancelledByTdNo   : info.cancelledByTdNo,
			taxpayerId        : info.taxpayerId,
			taxpayerName      : info.taxpayerName,
			taxpayerAddress   : info.taxpayerAddress,
			administratorId   : info.administratorId,
			administratorName : info.administratorName,
			administratorAddress : info.administratorAddress,
			appraisedBy          : info.appraisedBy,
			appraisedByTitle     : info.appraisedByTitle,
			recommendedBy        : info.recommendedBy,
			recommendedByTitle   : info.recommendedByTitle,
			reviewedBy           : info.reviewedBy,
			reviewedByTitle      : info.reviewedByTitle,
			approvedBy           : info.approvedBy,
			approvedByTitle      : info.approvedByTitle,

			barangay        : rp.barangay,
			cadastralLotNo  : rp.cadastralLotNo,
			blockNo         : rp.blockNo,
			surveyNo        : rp.surveyNo,
			houseNo         : rp.houseNo,
			street          : rp.street,
			purok           : rp.purok,
			north           : rp.north,
			south           : rp.south,
			east            : rp.east,
			west            : rp.west,

			ry         : rpu.ry,
			type       : rpu.type, 
			propertyDescription : getPropertyDescription( faas ),
			pin        : rpu.pin, 
			suffix     : rpu.suffix,
			subSuffix  : rpu.subSuffix,
			special    : rpu.special,
			taxable    : rpu.taxable,
			totalMV    : rpu.totalMV,
			totalAMV   : rpu.totalAMV,
			totalAV    : rpu.totalAV,
			areaSqm    : rpu.areaSqm,
			areaHec    : rpu.areaHec,
		]
	}
	
	private def getPropertyDescription( faas ) {
		def rpu = faas.rpu;
		def desc = '';
		if( rpu.rpuType == "rpubldg:bldg" ) 
			desc = rpu.info.bldgKindTitle;
		else if( rpu.rpuType == "rpumach:mach" ){
			rpu.info.machineUses?.each{ uses ->
				uses.machineDetails?.each{
					if( desc.length() > 0 ) desc += ', ';
					desc += it.machineTitle;
				}
			}
		}else if( rpu.rpuType == "rpumisc:misc" ){
			rpu.info.miscRpuItems?.each{
				if( desc.length() > 0 ) desc += ', ';
				desc += it.miscItemTitle;
			}
		}else if( rpu.rpuType == "rputree:tree" ){
			rpu.info.landPlantDetails?.each{
				if( desc.length() > 0 ) desc += ', ';
				desc += it.treeTitle;
			}
		}
		return desc;
	}
	
	private def buildAssessment( faas ) {
		def rpu = faas.rpu;
		if( faas.rpu.rpuType == "rpuland:land" ) 
			return processLand( rpu );
		else if( faas.rpu.rpuType == "rpubldg:bldg" ) 
			return buildItemList( rpu, rpu.info.bldgUses );
		else if( faas.rpu.rpuType == "rpumach:mach" ) 
			return buildItemList( rpu, rpu.info.machineUses );
		else if( faas.rpu.rpuType == "rpumisc:misc" ) 
			return buildItemList( rpu, rpu.info.miscRPUItems );
	}
	
	private def processLand( rpu ) {
		def itemList =[];
		itemList.addAll( buildItemList( rpu, rpu.info.landDetails ) );
		itemList.addAll( buildItemList( rpu, rpu.info.plantDetails ) );
		return itemList;
	}
	
	private def buildItemList( rpu, rpuItemList ) {
		def items =	[];
		rpuItemList.each {
			def key = rpu.info.classCode + it.actualUseCode;
			def item = items.find{ itm -> itm.key == key };
			def area = getAreaByRpuType(rpu.rpuType, it);
			if( !item  ) {
				item = createItem(
							key, 
							rpu.info.classCode, rpu.info.classTitle, 
							it.actualUseCode, it.actualUseTitle,
							it.marketValue, it.adjMarketValue, 
							it.assessLevel, it.assessedValue,
							area.sqm, area.hec
						);
				items.add(item);
			}
			else {
				summarizeAssessmentInfo( item, it.marketValue, it.adjMarketValue, it.assessedValue, area.sqm, area.hec);
			}
		}
		return items;
	}
	
	private def getAreaByRpuType( rpuType, item ) {
		def area = [sqm:0.0, hec:0.0];
		if( rpuType == "rpumach:mach" ) return area;
		if( rpuType == "rpumisc:misc" ) return area;
		if( rpuType == "rputree:tree" ) return area;
			
		if( rpuType == "rpuland:land" ) {
			area.sqm = item.areaSqm;
			area.hec = item.areaHec;
		}
		else if( rpuType == "rpubldg:bldg" )  {
			area.sqm = item.area;
			area.hec = item.area /10000;
		}
		return area;
	}
	
	private void summarizeAssessmentInfo( item, marketValue, adjMarketValue, assessedValue, areaSqm, areaHec  ) {
		item.marketValue    += marketValue
		item.adjMarketValue += adjMarketValue
		item.assessedValue  += assessedValue
		item.areaSqm        += areaSqm;
		item.areaHec        += areaHec;
	}
	
	private def createItem( key, classCode, classTitle, actualUseCode, actualUseTitle, marketValue, adjMarketValue, assessLevel, assessedValue, areaSqm, areaHec) {
		return [ 
			key 		   : key,
			classCode      : classCode,
			classTitle     : classTitle,
			actualUseCode  : actualUseCode,
			actualUseTitle : actualUseTitle,
			marketValue    : marketValue,
			adjMarketValue : adjMarketValue,
			assessLevel    : assessLevel,
			assessedValue  : assessedValue,
			areaSqm        : areaSqm,
			areaHec        : areaHec,
		];
	}
	
}
