/**
* Copyright: Rameses Systems Inc.
* Author   : jzamora 
*/
import com.rameses.scripting.annotations.*;
import com.rameses.tracs.common.DateUtil;
import com.rameses.tracs.common.MoneyUtil;
import com.rameses.tracs.rpt.domain.TxnType;
import com.rameses.tracs.rpt.rpu.RPU;
import com.rameses.tracs.taxpayer.Taxpayer;
import com.rameses.tracs.rpt.domain.DocumentState;
import com.rameses.tracs.rpt.collection.services.RPTLedgerQuery;
import com.rameses.tracs.rpt.td.TaxDeclaration;
import com.rameses.tracs.rpt.collection.RPTCollectionSetting;
import com.rameses.tracs.rpt.collection.RPTLedger;
import com.rameses.tracs.rpt.collection.RPTLedgerItem;
import com.rameses.tracs.rpt.collection.RPTLedgerState;
import com.rameses.tracs.rpt.collection.AbstractRPTCredit;
import com.rameses.tracs.rpt.collection.RPTCreditPayment;
import com.rameses.tracs.rpt.collection.RPTPaymentSchedule;
import com.rameses.tracs.rpt.collection.RPTReceiptPayment;
import com.rameses.tracs.rpt.collection.amnesty.RPTAmnesty;
import com.rameses.tracs.rpt.collection.amnesty.RPTAmnestyState;
import com.rameses.tracs.rpt.collection.rules.billing.*;

public class RPTLedgerService
{
	@Resource("defaultPU")
	def em;
	
	@ProxyMethod
	public BigDecimal checkArrears(RPU rpu) {
		//TODO:
        return BigDecimal.ZERO;
    }
	
	@ProxyMethod
	public RPTLedger createLedger(  TaxDeclaration td )  {
		def ledger = findLedgerByTdId( td.objid );
		if( isLedgerExists( ledger ) ) {
			return ledger;
		}
		return createLedgerFromTd( td );
    }
	
	@ProxyMethod
	public RPTLedger approveLedger(RPTLedger rledger) {
        RPTLedger ledger = findLedgerById(rledger.objid);
		validateLedgerApproval( ledger );
		calculateLastPaidYearAndQtr( ledger );
		approveLedgerItems( ledger );
		ledger.state = RPTLedgerState.APPROVED;
        return ledger;
    }
	
	@ProxyMethod
	public RPTLedger findLedgerById(String objid) {
        RPTLedger ledger = em.createQuery("SELECT o FROM RPTLedger o WHERE objid = :objid ")
									.setParameter("objid", objid)
									.singleResult;
		ledger.items.size();
		ledger.credits.size();
		return ledger;
    }
	
	@ProxyMethod
	public List getLedgers(RPTLedgerQuery query) {
        return em.createQuery("SELECT o FROM RPTLedger o " ).resultList;
    }
	
	@ProxyMethod
	public RPTLedger saveLedger(RPTLedger rpt) {
        RPTLedger old = em.find( RPTLedger.class, rpt.objid);
        if( old == null ) {
            throw new Exception( "RPT Ledger not found" );
		}
        
        //remove items
        List deleted = old.items;
        deleted.removeAll( rpt.items);
        for( item in deleted ) {
			em.remove( item );
		}
        
        //remove payments
        List deletedPmts = old.credits;
        deletedPmts.removeAll( rpt.credits );
        for( item in deletedPmts ) {
			em.remove( item );
		}
        em.merge( rpt );
        return rpt;
    }
	
	@ProxyMethod
	public List getOpenLedgersByTaxpayer(Taxpayer taxpayer) {
        int currYear = DateUtil.getYear(new Date());
		return em.createQuery('''
					SELECT o.tdno FROM RPTLedger o
					WHERE o.taxpayerId = :taxpayerId AND o.state = :state 
					  AND o.lastYearPaid <> :lastYearPaid AND o.lastQtrPaid <> 4 AND o.partialPayment = 0
				''').setParameter("taxpayerId", taxpayer.objid)
					.setParameter("state", RPTLedgerState.APPROVED)
					.setParameter("lastYearPaid", currYear)
					.resultList;
    }
	
	@ProxyMethod
	public void validateNewPropertyPayerLedger(String user, String ledgerId) {
		List list = em.createQuery('SELECT o FROM PropertyPayerLedger o WHERE ledgerId = :ledgerId')
								.setParameter("ledgerId", ledgerId)
								.resultList;
		if(list.size() > 0) {
			throw new Exception('This property is currently assigned to ${list[0].propertyPayer.payerName}.');
		}
	}
	
	@ProxyMethod
	public def findLedgerByTdId( def tdId ) {
		List list = em.createQuery('''
						SELECT o FROM RPTLedger o WHERE o.tdid = :tdid 
					''').setParameter("tdid", tdId).setMaxResults(1).resultList;
        if(list.size() > 0) {
            return list.get(0);
        }
		return null;
	}
	
	private boolean isLedgerExists( def ledger ) {
		return (ledger != null);
	}
	
	private def createLedgerFromTd( def td ) {
		RPTLedger rpt = new RPTLedger();
        rpt.updateInfo(td);
        rpt.dtcreated  = new Date();
		
		def item = addLedgerItemByTd( rpt, td );
		addBackTaxItemByTd( rpt, td, item);
		
        em.persist( rpt );
        return  rpt;
	}
	
	private def addLedgerItemByTd( def rpt, def td ) {
		RPTLedgerItem item = new RPTLedgerItem();
        item.tdno = td.tdno;
        item.fromYear = td.effectivityYear;
        item.fromQtr = td.effectivityQtr;
        item.tdno = td.tdno;
		item.assessedValue = td.rpu.totalAV;
        item.systemCreated = true;
        rpt.addItem( item );
		return item;
	}
	
	private void addBackTaxItemByTd( def rpt, def td, def item ) {
		if(td.txnType == TxnType.ND && td.backTaxYears > 0) {
            RPTLedgerItem backtaxItem = addLedgerItemByTd( rpt, td );
            backtaxItem.fromYear = item.fromYear - td.backTaxYears;
            backtaxItem.fromQtr = 1;
            backtaxItem.toYear = item.fromYear - 1;
            backtaxItem.toQtr = 4;
            backtaxItem.backTax = true;
            backtaxItem.systemCreated = true;
        }
	}
	
	
	/* approveLedger support */
	private void validateLedgerApproval( def ledger ) {
		if( ledger.state == RPTLedgerState.CANCELLED ) {
            throw new Exception("Ledger has already been cancelled");
		}
        if( ledger.state == RPTLedgerState.APPROVED ) {
            throw new Exception("Ledger has already been approved");
		}
	}
	
	private void calculateLastPaidYearAndQtr( def ledger ) {
		//find the highest payment year and quarter.
        if( ledger.credits.size() > 0 ) {
            AbstractRPTCredit maxPayment = Collections.min(ledger.credits);
            ledger.lastYearPaid = maxPayment.toYear;
            ledger.lastQtrPaid = maxPayment.toQtr;
        } 
		else if(ledger.items.size() > 0){
            RPTLedgerItem ri = Collections.min(ledger.items);
            ledger.lastYearPaid = ri.fromYear - 1;
            ledger.lastQtrPaid = 4;
        }
	}
	
	private void approveLedgerItems( def ledger ) {
		ledger.items.each { item -> item.state = DocumentState.APPROVED; }	
	}

}	
