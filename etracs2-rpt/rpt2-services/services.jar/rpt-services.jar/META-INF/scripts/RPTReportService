import com.rameses.annotations.*
import com.rameses.eserver.*;
import com.rameses.common.*;
import java.rmi.server.UID

class RPTReportService
{
    @PersistenceContext('main')
    def em
     
	@Service('DateService')
    def dateSvc
	
	@Service('SequenceService')
	def seqSvc
	
	@Service('Var')
	def var 
	
	@Env
	def env
    
    @ProxyMethod
	public def generateNotice( notice ) {
		notice.items = []
		if(  notice.faasid ) {
			notice.items = em.sqlContext.createNamedQuery('rptreport:getNoticeItemsByFaasid').setParameter('objid', notice.faasid).resultList
		}
		else {
			def rptsetting 	= em.sqlContext.createNamedQuery('rptreport:getRPTSetting').singleResult
			notice.ry 		= rptsetting?.ry 
			notice.items 	= em.sqlContext.createNamedQuery( 'rptreport:getNoticeItemsByTaxpayerId' ).setParameter('taxpayerid', notice.taxpayerid).resultList
		}
		if( ! notice.items ) throw new Exception('Records not found.\nPleas verify that FAAS records are current.')
		
		notice.docno 			= seqSvc.getNextFormattedSeries( 'NOTICEOFASSESSMENT' )
		notice.objid			= notice.docno 
		notice.docstate			= 'OPEN'
		
		notice.issuedate 		= dateSvc.serverDate
		notice.preparedby 		= env.USERFORMALNAME
		notice.preparedbytitle	= (env.JOBTITLE ? env.JOBTITLE : '-' )
		notice.approvedby		= var.assessor_name
		notice.approvedbytitle  = var.assessor_title
		notice.lgutype			= var.lgu_type
		notice.parentlguname	= var.parent_lgu_formal_name
		notice.lguname			= var.lgu_formal_name
		
		em.validate( 'rptreport:noticeofassessment', notice )
		em.create( 'rptreport:noticeofassessment', notice )
		return notice 
	}
	
	@ProxyMethod 
	public def openNotice( noticeid ) {
		return em.read('rptreport:noticeofassessment', [objid:noticeid] )
	}
	
	@ProxyMethod
	public List getNoticeList( searchText ) {
		return em.sqlContext.createNamedQuery('rptreport:getNoticeList').setMaxResults(50).resultList 
	}
	
	
	@ProxyMethod
	public def generateAssessmentRollTaxable( params )  {
		resolveSection( params )
		def list = em.sqlContext.createNamedQuery('rptreport:getAssessmentRollTaxable').setParameters( params ).resultList
		if( ! list ) throw new Exception('Records not found.')
		return list 
	}
	
	@ProxyMethod
	public def generateAssessmentRollExempt( params )  {
		resolveSection( params )
		def list = em.sqlContext.createNamedQuery('rptreport:getAssessmentRollExempt').setParameters( params ).resultList
		if( ! list ) throw new Exception('Records not found.')
		return list 
	}
	
	@ProxyMethod
	public def generateTMCR( params )  {
		resolveSection( params )
		def list = em.sqlContext.createNamedQuery('rptreport:getTmcrList').setParameters( params ).resultList
		if( ! list ) throw new Exception('Records not found.')
		return list 
	}
	
	@ProxyMethod
	public def generateORF( taxpayerid )  {
		def list = em.sqlContext.createNamedQuery('rptreport:getORF').setParameter( 'taxpayerid', taxpayerid ).resultList
		if( ! list ) throw new Exception('Records not found.')
		def total = 0
		list.each {
			total += it.totalav 
			it.runningtotal = total 
		}
		return list 
	}
	
	

	
	
	@ProxyMethod
	public List getBarangayList() {
		return em.sqlContext.createNamedQuery('rptreport:getBarangayList').setParameter('parentid', var.lgu_index ).resultList 
	}
	
	
	void resolveSection( params ) {
		if( ! params.section || params.section == 0 ) {
			params.section = '%' 
		}
		else {
			int sectionlen  = 0
			try {
				sectionlen = Integer.parseInt( var.pin_section_length )
			}
			catch( e ) {
				sectionlen = 3 
			}
			params.section = (params.section+'').padLeft( sectionlen, '0' )
		}
	}
}
