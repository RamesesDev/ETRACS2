import com.rameses.annotations.*
import com.rameses.eserver.*;
import com.rameses.common.*;
import java.rmi.server.UID

class RPTReportService
{
    @PersistenceContext('main')
    def em
     
	@Service('DateService')
    def dateSvc
	
	@Service('SequenceService')
	def seqSvc
	
	@Service('Var')
	def var 
	
	@Env
	def env
    
    @ProxyMethod
	public def generateNotice( notice ) {
		notice.items = []
		if(  notice.faasid ) {
			notice.items = em.sqlContext.createNamedQuery('rptreport:getNoticeItemsByFaasid').setParameter('objid', notice.faasid).resultList
		}
		else {
			def rptsetting 	= em.sqlContext.createNamedQuery('rptreport:getRPTSetting').singleResult
			notice.ry 		= rptsetting?.ry 
			notice.items 	= em.sqlContext.createNamedQuery( 'rptreport:getNoticeItemsByTaxpayerId' ).setParameter('taxpayerid', notice.taxpayerid).resultList
		}
		if( ! notice.items ) throw new Exception('Records not found.\nPleas verify that FAAS records are current.')
		
		notice.docno 			= seqSvc.getNextFormattedSeries( 'NOTICEOFASSESSMENT' )
		notice.objid			= notice.docno 
		notice.docstate			= 'OPEN'
		
		notice.issuedate 		= dateSvc.serverDate
		notice.preparedby 		= env.USERFORMALNAME
		notice.preparedbytitle	= (env.JOBTITLE ? env.JOBTITLE : '-' )
		notice.approvedby		= var.assessor_name
		notice.approvedbytitle  = var.assessor_title
		notice.lgutype			= var.lgu_type
		notice.parentlguname	= var.parent_lgu_formal_name
		notice.lguname			= var.lgu_formal_name
		
		em.validate( 'rptreport:noticeofassessment', notice )
		em.create( 'rptreport:noticeofassessment', notice )
		return notice 
	}
	
	@ProxyMethod 
	public def openNotice( noticeid ) {
		return em.read('rptreport:noticeofassessment', [objid:noticeid] )
	}
	
	@ProxyMethod
	public List getNoticeList( searchText ) {
		return em.sqlContext.createNamedQuery('rptreport:getNoticeList').setMaxResults(50).resultList 
	}
	
	
	@ProxyMethod
	public def generateAssessmentRollTaxable( params )  {
		resolveSection( params )
		def list = em.sqlContext.createNamedQuery('rptreport:getAssessmentRollTaxable').setParameters( params ).resultList
		if( ! list ) throw new Exception('Records not found.')
		return list 
	}
	
	@ProxyMethod
	public def generateAssessmentRollExempt( params )  {
		resolveSection( params )
		def list = em.sqlContext.createNamedQuery('rptreport:getAssessmentRollExempt').setParameters( params ).resultList
		if( ! list ) throw new Exception('Records not found.')
		return list 
	}
	
	@ProxyMethod
	public def generateTMCR( params )  {
		resolveSection( params )
		def list = em.sqlContext.createNamedQuery('rptreport:getTmcrList').setParameters( params ).resultList
		if( ! list ) throw new Exception('Records not found.')
		return list 
	}
	
	@ProxyMethod
	public def generateORF( taxpayerid )  {
		def list = em.sqlContext.createNamedQuery('rptreport:getORF').setParameter( 'taxpayerid', taxpayerid ).resultList
		if( ! list ) throw new Exception('Records not found.')
		def total = 0
		list.each {
			total += it.totalav 
			it.runningtotal = total 
		}
		return list 
	}
	
	@ProxyMethod
	public def generateJAT( barangayid )  {
		def list = em.sqlContext.createNamedQuery('rptreport:getJAT').setParameter( 'barangayid', barangayid).resultList
		if( ! list ) throw new Exception('Records not found.')
		return list 
	}
	
	
	@ProxyMethod
	public Map generateAccomplishmentRPA( year, qtr, month ) {
		def title 		= 'QUARTERLY ACCOMPLISHMENT REPORT ON REAL PROPERTY ASSESSMENTS'
		def period 		= 'FOR THE ' + getQuarterName( qtr ) + ' OF ' + year 
		def periodtype 	= 'QUARTER'
		if( month && month > 0 ) {
			title = 'MONTHLY ACCOMPLISHMENT REPORT ON REAL PROPERTY ASSESSMENTS'
			period = 'FOR THE MONTH OF ' + getMonthName( month ) + ', ' + year 
			periodtype = 'MONTH' 
		}
		
		def params = [ lguindex:var.lgu_index ]
		params.txntimestamp = resolveTimeStamp( year, qtr, month, (month ? 1 : null)  )
		def preceedingassessments = em.sqlContext.createNamedQuery('rptreport:getPreceedingRPAAccomplishment').setParameters( params ).resultList 
		
		params.txntimestamp = resolveTimeStamp( year, qtr, month, null )
		def currentassessments = em.sqlContext.createNamedQuery('rptreport:getCurrentRPAAccomplishment').setParameters( params ).resultList 
		def cancelledassessments = em.sqlContext.createNamedQuery('rptreport:getCancelledRPAAccomplishment').setParameters( params ).resultList 
		
		params.txntimestamp = resolveTimeStamp( year, qtr, (month ? month+1 : null ), (month ? 1 : null) )
		def endingassessments = em.sqlContext.createNamedQuery('rptreport:getEndingRPAAccomplishment').setParameters( params ).resultList 
		
		def loadSumaryInfo = { lgu, list ->
			def info = list.find{ it.barangayid == lgu.objid }
			if( info ) lgu.putAll( info )
		}
	
		def lgulist = getBarangayList().collect { 
			[ 	objid 		: it.objid, 
				barangay	: it.barangay, 
				preceedingtaxablecount 	: 0.0,
				preceedingtaxableav 	: 0.0,
				preceedingexemptcount 	: 0.0,
				preceedingexemptav 		: 0.0,
				
				currenttaxablecount 	: 0.0,
				currenttaxableav 		: 0.0,
				currentexemptcount 		: 0.0,
				currentexemptav 		: 0.0,
				
				cancelledtaxablecount 	: 0.0,
				cancelledtaxableav 		: 0.0,
				cancelledexemptcount 	: 0.0,
				cancelledexemptav 		: 0.0,
				
				endingtaxablecount 		: 0.0,
				endingtaxableav 		: 0.0,
				endingexemptcount 		: 0.0,
				endingexemptav 			: 0.0,
			]
		}
		lgulist.each { lgu ->
			loadSumaryInfo( lgu, preceedingassessments )
			loadSumaryInfo( lgu, currentassessments )
			loadSumaryInfo( lgu, cancelledassessments )
			loadSumaryInfo( lgu, endingassessments )
		}
		
		lgulist.add([
			barangay	: 'TOTAL',
			preceedingtaxablecount	: lgulist.preceedingtaxablecount.sum(),
			preceedingtaxableav	: lgulist.preceedingtaxableav.sum(),
			preceedingexemptcount	: lgulist.preceedingexemptcount.sum(),
			preceedingexemptav	: lgulist.preceedingexemptav.sum(),
			currenttaxablecount	: lgulist.currenttaxablecount.sum(),
			currenttaxableav	: lgulist.currenttaxableav.sum(),
			currentexemptcount	: lgulist.currentexemptcount.sum(),
			currentexemptav	: lgulist.currentexemptav.sum(),
			cancelledtaxablecount	: lgulist.cancelledtaxablecount.sum(),
			cancelledtaxableav	: lgulist.cancelledtaxableav.sum(),
			cancelledexemptcount	: lgulist.cancelledexemptcount.sum(),
			cancelledexemptav	: lgulist.cancelledexemptav.sum(),
			endingtaxablecount	: lgulist.endingtaxablecount.sum(),
			endingtaxableav	: lgulist.endingtaxableav.sum(),
			endingexemptcount	: lgulist.endingexemptcount.sum(),
			endingexemptav	: lgulist.endingexemptav.sum(),
		])
		
		return [
			period 		: period,
			periodtype 	: periodtype,
			title 		: title,
			reportdata  : lgulist,
		]
	}
	
		
	
	
	
	@ProxyMethod
	public List getBarangayList() {
		return em.sqlContext.createNamedQuery('rptreport:getBarangayList').setParameter('parentid', var.lgu_index ).resultList 
	}
	
	@ProxyMethod
	public List getMonthList( qtr ) {
		def months = [
			[name:'JANUARY', 	month:1, qtr:1 ],
			[name:'FEBRUARY', 	month:2, qtr:1 ],
			[name:'MARCH', 		month:3, qtr:1 ],
			
			[name:'APRIL', 	month:4, qtr:2 ],
			[name:'MAY', 	month:5, qtr:2 ],
			[name:'JUNE', 	month:6, qtr:2 ],
			
			[name:'JULY', 		month:7, qtr:3 ],
			[name:'AUG', 		month:8, qtr:3 ],
			[name:'SEPTEMBER', 	month:9, qtr:3 ],
			
			[name:'OCTOBER', 	month:10, qtr:4 ],
			[name:'NOVEMBER', 	month:11, qtr:4 ],
			[name:'DECEMBER', 	month:12, qtr:4 ],
		]
		
		if( ! qtr ) return months 
		return months.findAll{ it.qtr == qtr }
	}
	
	def getMonthName( month ) {
		def months = getMonthList( null )
		def mon = months.find{ it.month = month }
		if( mon ) return mon.name 
		throw new Exception("Month $month is not defined." )
	}
	
	def getQuarterName( qtr ) {
		if( qtr == 1 ) return '1ST QUARTER'
		else if( qtr == 2 ) return '2ND QUARTER'
		else if( qtr == 3 ) return '3RD QUARTER'
		return '4TH QUARTER'
	}
	
	
	String padLeft( val, len ) {
		return "$val".padLeft( len, '0' )
	}
	
	void resolveSection( params ) {
		if( ! params.section || params.section == 0 ) {
			params.section = '%' 
		}
		else {
			int sectionlen  = 0
			try {
				sectionlen = Integer.parseInt( var.pin_section_length )
			}
			catch( e ) {
				sectionlen = 3 
			}
			params.section = (params.section+'').padLeft( sectionlen, '0' )
		}
	}
	
	def resolveTimeStamp( year, qtr, month, day ) {
		//build timestamp progressively based on the passed values, e.g.,
		//if month is null then timestamp is resolve upto the qtr info, such as "20111%" for 1st qtr
		//if month is notnull thne it is resolve upto the month, such as "2011102%" for 2nd qtr 
		def timestamp = year + '' + qtr 
		if( month != null ) timestamp += padLeft( month, 2 )
		if( day != null ) timestamp += padLeft( day, 2 )
		if( month == null  || day == null ) timestamp += '%'
		return timestamp
		
	}
}
