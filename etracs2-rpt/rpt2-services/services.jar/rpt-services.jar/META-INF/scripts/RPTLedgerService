import com.rameses.annotations.*
import java.rmi.server.UID
import com.rameses.eserver.*;
import com.rameses.common.*;

class RPTLedgerService
{
	@PersistenceContext('main')
	def em
    
	@Service('DateService')
	def dateSvc

    @Service('Var')
	def var

	@Service('LogService')
    def logSvc
    
    def PENDING_STATE = 'PENDING'
    def APPROVED_STATE = 'APPROVED'
    def CANCELLED_STATE = 'CANCELLED'
    
    def LAND_TYPE = 'land' 
    def BLDG_TYPE = 'bldg'
    def MACH_TYPE = 'mach'
    def PLANTTREE_TYPE = 'planttree'
    def MISC_TYPE = 'misc' 
    
    def FAASLISTSCHEMA_NAME = 'faas:faaslist'
    def LEDGER_SCHEMA = 'rptledger' 
    def LEDGERITEM_SCHEMA = 'rptledger:rptledgeritem' 
    def SCHEMA_VERSION = '1.0'
    
	@ProxyMethod
    public void post( faasid ) {
        def faas = openFaas( faasid )
        if( faas.datacapture == true ) postDataCapture( faas )
        else if( 'TR/RE/CE'.indexOf( faas.txntype ) >= 0 ) postTransaction( faas ) 
        else throw new Exception('RPTLedgerService.post: Posting of TxnType ' + faas.txntype + ' is not yet supported.')        
    }
    
    void postDataCapture( faas ) {
        def ledger = createLedger( faas, PENDING_STATE )
        def ledgeritem = createLedgerItem( ledger )
        em.validate( ledger.schemaname, ledger ) 
        em.validate( ledgeritem.schemaname, ledgeritem ) 
        em.create( ledger.schemaname, ledger )
        em.create( ledgeritem.schemaname, ledgeritem )
    }
    
    void postTransaction( faas ) {
        def ledger = updateLedger( faas  )
        def ledgeritem = createLedgerItem( ledger ) 
        closePreviousLedgerItemToYear( ledger, faas )
        em.update( ledger.schemaname, ledger )
        em.create( ledgeritem.schemaname, ledgeritem )
    }
    
    /* ------------------------------------------------------------------------
    * Support Methods 
    ------------------------------------------------------------------------ */
    Map createLedger( faas, state ) {
        def ledger = [:]
        ledger.putAll( faas )
        ledger.objid            = faas.fullpin 
        ledger.schemaname       = LEDGER_SCHEMA
        ledger.schemaversion    = SCHEMA_VERSION
        ledger.faasid           = faas.objid 
        ledger.docstate         = state
        ledger.assessedvalue    = faas.totalav 
        ledger.lastyearpaid     = ( faas.effectivityqtr == 1 ? faas.effectivityyear - 1 : faas.effectivityyear)
        ledger.lastqtrpaid      = ( faas.effectivityqtr == 1 ? 4 : faas.effectivityqtr - 1 )
        ledger.partialbasic     = 0.0
        ledger.partialsef       = 0.0
        ledger.firstqtrpaidontime = false 
        updateActualUseInfo( ledger )
        return ledger
    }
    
    Map updateLedger( faas ) {
        def oldledger = openLedger( faas )
        def ledgerid = oldledger.objid 
        def oldstate = oldledger.docstate 
        oldledger.putAll( faas )
        oldledger.objid            = ledgerid
        oldledger.docstate         = oldstate 
        oldledger.schemaname       = LEDGER_SCHEMA
        oldledger.schemaversion    = SCHEMA_VERSION
        oldledger.assessedvalue    = faas.totalav 
        updateActualUseInfo( faas )
        return oldledger
    }
    
    Map createLedgerItem( ledger  ) {
        def ledgeritem = [:]
        ledgeritem.putAll( ledger )
        ledgeritem.objid            = 'LI' + new UID()
        ledgeritem.schemaname       = LEDGERITEM_SCHEMA
        ledgeritem.schemaversion    = SCHEMA_VERSION
        ledgeritem.docstate         = APPROVED_STATE
        ledgeritem.parentid         = ledger.objid 
        ledgeritem.faasid           = ledger.faasid 
        ledgeritem.fromyear         = ledger.effectivityyear
        ledgeritem.toyear           = 0
        ledgeritem.assessedvalue    = ledger.assessedvalue 
        ledgeritem.backtax          = (ledger.backtaxyrs > 0)
        ledgeritem.systemcreated    = true 
        return ledgeritem 
    }
    
    void updateActualUseInfo( ledger  ) {
        //TODO: how to identify actualuse for split assessments? 
        //by default set it to the largest area
        ledger.actualuseid = ledger.classid 
        ledger.actualusecode = ledger.classcode 
    }
    
    Map openFaas( faasid )  {
        def faas = em.read( FAASLISTSCHEMA_NAME, [objid:faasid] )
        faas.datacapture    = faas.datacapture as boolean 
        faas.taxable        = faas.taxable as boolean 
        return faas 
    }
    
    Map openLedger( faas ) {
        def ledger = em.read(LEDGER_SCHEMA, [ objid:faas.fullpin] )
        if( ! ledger ) throw new Exception('Ledger for FAAS ' + faas.tdno  + ' does not exists.\nKindly ask assistance from Land Tax.')
        return ledger 
    }
    
    void closePreviousLedgerItemToYear( ledger, faas ) {
        //previous item is the lastest entry in the ledger
        //and is denoted by the toyear = 0
        def item = em.sqlContext.createNamedQuery('rptledger:getLatestItem').setParameter('parentid', ledger.objid ).singleResult
        if( ! item ) throw new Exception('Cannot locate the last ledger entry.\nPlease verify that it has not been deleted.')
        item.toyear  = faas.effectivityyear - 1
        if( item.fromyear == faas.effectivityyear ) {
            item.toyear   = faas.effectivityyear
            item.docstate = CANCELLED_STATE 
        }
        em.update( item.schemaname, item )
    }
}

