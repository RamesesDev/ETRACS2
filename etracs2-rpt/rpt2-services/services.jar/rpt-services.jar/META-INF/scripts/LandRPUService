import com.rameses.annotations.*
import java.rmi.server.UID

class LandRPUService
{
	@PersistenceContext('main')
	def em
    
    @Service('NumberService')
	def numberSvc
    
    @Service('RPUService')
	def rpuSvc

	@Env
	def env
    
    
    
    
    @ProxyMethod
    public Map initLandRpu( rpu ) {
        rpuSvc.buildCommonRpuInfo( rpu )
        def rpuinfo = rpu.info 
        //
        //land specific info
        rpuinfo.idleland = false 
        rpuinfo.landvalueadjustment = 0.0
        rpuinfo.landdetails = []
        rpuinfo.landtotal = [ 
            areasqm         : 0.0,
            areaha          : 0.0,
            basemarketvalue : 0.0,
            adjustment      : 0.0,
            marketvalue     : 0.0,
            assessedvalue   : 0.0,
        ]
        rpuinfo.planttrees = []
        rpuinfo.planttotal = [
            bearing         : 0,
            nonbearing      : 0,
            basemarketvalue : 0.0,
            adjustment      : 0.0,
            marketvalue     : 0.0,
            assessedvalue   : 0.0,
        ]
        rpuinfo.adjustments = []
        return rpu
    }
    
    
    @ProxyMethod
    public Map calculateLandDetailAssessment( landdetail ) {
        //calculate areas 
        if( landdetail.areatype == 'SQM' ) {
            landdetail.areasqm = landdetail.area 
            landdetail.areaha  = landdetail.area / 10000.0
        }
        else {
            landdetail.areasqm = landdetail.area * 10000.0
            landdetail.areaha  = landdetail.area 
        }
        
        //adjust unitvalue if stripping is set 
        if( landdetail.stripping && landdetail.stripping.striprate > 0) {
            landdetail.strippingid = landdetail.stripping.objid 
            landdetail.striprate   = landdetail.stripping.striprate 
            landdetail.unitvalue = numberSvc.round( landdetail.basevalue * landdetail.striprate / 100.0 )
        }
        
        //reset values to 0.0
        landdetail.basemarketvalue  = 0.0
        landdetail.marketvalue      = 0.0
        landdetail.assesslevel      = 0.0
        landdetail.assessedvalue    = 0.0
        
        //calculate assessment 
        if( landdetail.taxable ) {
            landdetail.basemarketvalue = numberSvc.round( landdetail.area * landdetail.unitvalue )
            landdetail.landvalueadjustment = calculateLandValueAdjustment( landdetail )
            landdetail.actualuseadjustment = calculateActualUseAdjustment( landdetail )
            landdetail.adjustment = numberSvc.round( landdetail.landvalueadjustment + landdetail.actualuseadjustment )
            landdetail.marketvalue = numberSvc.round( landdetail.basemarketvalue + landdetail.adjustment )
            landdetail.assesslevel = determineAssessLevel( landdetail )
            landdetail.assessedvalue = numberSvc.roundToTen(landdetail.marketvalue * landdetail.assesslevel / 100.0 )
        }
        return landdetail 
    }
    
    @ProxyMethod
    public List recalcLandDetails( landdetails ) {
        landdetails.each { calculateLandDetailAssessment( it ) }
        return landdetails 
    }
    
    
    @ProxyMethod
    public def calculateLandAdjustment( landdetails, adjustment ) {
        def result = [landvalueadjustment:0.0]
        landdetails.each {
            // evaluate the expr
            def binding = buildFieldBindings( it ) 
            binding += buildParamBindings( adjustment )
            def adjamout = numberSvc.round( evaluateExpr( adjustment.expr, binding ) )
            result.landvalueadjustment += adjamout
            //remove existing adjustment
            def oldadj = it.landadjustments.find{ it.adjtypeid == adjustment.adjtypeid }
            if( oldadj ) it.landadjustments.remove( oldadj )
            //add the adjustment 
            it.landadjustments.add( createAdjustment( adjustment, adjamout ) )
            calculateLandDetailAssessment( it )
        }
        result.landdetails = landdetails 
        return result 
    }
    
    @ProxyMethod
    public def calculateLandActualUseAdjustment( landdetail, adjtype) {
        def binding = buildFieldBindings( landdetail )
        binding += buildParamBindings( adjtype )
        adjtype.adjustment = numberSvc.round( evaluateExpr( adjtype.expr, binding ) )
        return adjtype 
    }
    
    
    @ProxyMethod
    public def applyLandAdjustments( landdetail, adjustments ) {
        adjustments.each { adj ->
            def data = calculateLandAdjustment( [landdetail], adj )
            adj.adjustment += data.landvalueadjustment
        }
        return [landdetail:landdetail, adjustments:adjustments]
    }
    
    def createAdjustment( adjtype , adjustment  ){
        return [
            objid       : 'LA' + new UID(),
            adjustment  : adjustment,
            adjtypeid   : adjtype.adjtypeid,
            adjtypecode : adjtype.adjtypecode,
            adjtypename : adjtype.adjtypename,
            expr        : adjtype.expr,
        ]
    }
    
    @ProxyMethod
    public def removeLandAdjustment( landdetails, item ) {
        landdetails.each {
            def adj = it.landadjustments.find{ it.adjtypeid == item.adjtypeid }
            if( adj ) it.landadjustments.remove( adj )
            calculateLandDetailAssessment( it )
        }
        return landdetails 
    }
    
    @ProxyMethod
    public def removeActualUseAdjustment( landDetail, item ) {
        def adj = landDetail.adjustments.find{ it.adjtypeid == item.adjtypeid }
        if( adj ) landDetail.adjustments.remove( adj )
        calculateLandDetailAssessment( landDetail )
        return landDetail 
    }
    
    /*----------------------------------------------------------------------------------
    * Lookup Support
    ----------------------------------------------------------------------------------*/
    @ProxyMethod
    public List lookupSubclass( ry, searchText, params) {
        def searchValue = (searchText ? searchText+'%' : '%')
        def criteria = [ry:ry, subclasscode:searchValue]
        return getListByName('landrpu:lookupSubclass', criteria, params)
    }
    
    @ProxyMethod
    public List lookupAssessLevel( ry, searchText, params) {
        def searchValue = (searchText ? searchText+'%' : '%')
        def criteria = [ry:ry, classcode:searchValue]
        return getListByName('landrpu:lookupAssessLevel', criteria, params)
    }
    
    @ProxyMethod
    public List lookupStripping( ry, actualuseid, searchText, params) {
        def searchValue = (searchText ? searchText : '-1')
        def criteria = [ry:ry, actualuseid:actualuseid, striplevel:searchValue ]
        return getListByName('landrpu:lookupStripping', criteria, params)
    }
    
    @ProxyMethod
    public List lookupLandAdjustments( ry, classid, searchText, params) {
        def searchValue = (searchText ? searchText+'%' : '%')
        def criteria = [ry:ry, classid:'%'+classid+'%', code:searchValue ]
        return getListByName('landrpu:lookupAdjType', criteria, params)
    }
    
    
    /*----------------------------------------------------------------------------------
    * calculateTotals Support 
    ----------------------------------------------------------------------------------*/
    def determineAssessLevel( landdetail ) {
        def al = em.sqlContext.createNamedQuery('landrpu:getAssessLevelById').setParameter('objid', landdetail.assesslevelid).singleResult
        if( ! al ) throw new Exception('Assess Level for ' + landdetail.assesslevelname + ' does not exists or has been deleted.')
        if( (al.fixrate as boolean ) ==  true ) {
            return al.rate 
        }
        List ranges = em.serializer.read( al.ranges )
        def range = ranges.find{ landdetail.marketvalue > it.from && (landdetail.marketvalue <= it.to || it.to == 0.0) }
        if( ! range ) throw new Exception('Market Value of P' + numberSvc.format('#,##0.00', landdetail.marketvalue) + ' has no assess level range definition.' )
        return range.rate 
    }
    
    def calculateLandValueAdjustment( ld ) {
        if( ld.landadjustments ) {
            return ld.landadjustments.adjustment.sum() 
        }
        return 0.0 
    }
    
    def calculateActualUseAdjustment( ld ) {
        if( ld.adjustments ) {
            return ld.adjustments.adjustment.sum() 
        }
        return 0.0 
    }
    
    /*----------------------------------------------------------------------------------
    * Miscellaneous Methods
    ----------------------------------------------------------------------------------*/
    def buildFieldBindings( landdetail ) {
        return [
            SYS_BASE_MARKET_VALUE       : landdetail.basemarketvalue,
            SYS_MARKET_VALUE            : landdetail.marketvalue,
            SYS_BASE_VALUE              : landdetail.basevalue,
            SYS_UNIT_VALUE              : landdetail.unitvalue,
            SYS_AREA                    : landdetail.area ,
            SYS_ASSESSED_VALUE          : landdetail.assessedvalue,
        ]
    }
    
    def buildParamBindings( adjustment ) {
        def binding = [:]
        adjustment.params.each {
            binding[it.paramname] = it.paramvalue 
        }
        return binding 
    }
    
    def getListByName(namedQuery, values, params ) {
		if( ! params ) params = [ _start:0, _limit:50 ]
		return em.sqlContext.createNamedQuery( namedQuery ).setParameters(values)
					.setFirstResult( params._start )
					.setMaxResults( params._limit )
					.resultList
	}
    
    def evaluateExpr( expr, params ) {
		return (new GroovyShell( new Binding( params) )).evaluate( expr )
	}
}
