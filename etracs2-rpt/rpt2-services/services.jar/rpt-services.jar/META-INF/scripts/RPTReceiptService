import com.rameses.annotations.*
import java.rmi.server.UID

class RPTReceiptService
{
	@PersistenceContext('main')
	def em
    
    @Service('ReceiptService')
	def receiptSvc
    
    @Service('DateService')
	def dateSvc

	@Env
	def env
    
    
    @ProxyMethod
    public def create( receipt, items ) {
        if( items.size() > 5 ) throw new Exception('Only 5 ledgers for payment is allowed.')
        
        buildReceiptItems( receipt, items )
        updateReceiptInfos( receipt, items )
        receiptSvc.create( receipt )
        //post rptpayment 
        items.each { item ->
            def rptpayment = createRPTPayment( receipt, item )
            em.validate(rptpayment.schemaname, rptpayment )
            em.create(rptpayment.schemaname, rptpayment )
            //post paymentdetail
            item.details.each { detail ->
                def pmtdetail = createRPTPaymentDetail( receipt, rptpayment, detail )
                em.validate( pmtdetail.schemaname, pmtdetail )
                em.create( pmtdetail.schemaname, pmtdetail )
            }
            updateLedgerLastYearQtrPaid([ objid:item.objid, lastyearpaid:item.toyear, lastqtrpaid:item.toqtr ] )
        }

        receipt._items = items.each(){
			it.taxpayername = ( it.taxpayername != receipt.info.payorname ) ? it.taxpayername : '';
		}
		
        return receipt 
    }
    
    @ProxyMethod
    public Map open( receiptid ) {
        def receipt = em.read('receipt', [objid:receiptid])
        receipt._items = loadRPTPayments( receiptid ).each(){
			it.taxpayername = ( it.taxpayername != receipt.info.payorname ) ? it.taxpayername : '';
		}
		
        return receipt 
    }
    
    @ProxyMethod
    public void voidReceipt( receiptid, reason ) {
        //TODO: check if this is the latest receipt for the ledgers
        receiptSvc.voidReceipt( receiptid, reason )
        voidRPTPayments( receiptid )
    }
    
    /*===========================================================================================
    *
    * SUPPORT METHODS
    *
    *===========================================================================================*/
    List loadRPTPayments( receiptid ) {
        return em.sqlContext.createNamedQuery('rptreceipt:getRPTPayments').setParameter('receiptid', receiptid ).resultList 
    }
    
    
    void voidRPTPayments( receiptid ) {
        def paymentinfos = em.sqlContext.createNamedQuery('rptreceipt:getRPTPaymentInfo').setParameter('receiptid', receiptid).resultList
        paymentinfos.each { pmt  ->
            updateLedgerLastYearQtrPaid([ 
                objid           : pmt.rptledgerid, 
                lastyearpaid    : ( pmt.fromqtr == 1 ? pmt.fromyear - 1 : pmt.fromyear ),
                lastqtrpaid     : ( pmt.fromqtr == 1 ? 4 : pmt.fromqtr - 1 ),
            ])
            //void rptpayment
            em.sqlContext.createNamedExecutor('rptreceipt:voidRPTPayment').setParameter('objid', pmt.objid).execute()
        }
    }
    
    void updateReceiptInfos( receipt, items ) {
        receipt.checknos   =  ''
        receipt.checkbank  = ''
        
        def noncashpmts = receipt.payments.findAll{ it.paytype == 'CHECK' } 
        if( noncashpmts ){
            receipt.checknos    = noncashpmts.checkno.join(',')
            receipt.checkbanks  = noncashpmts.bank.join(',')
            receipt.checkamount = noncashpmts.amount.sum()
        }
        
        receipt.basic       = 0.0          
        receipt.basicint    = 0.0
        receipt.basicdisc   = 0.0
        receipt.basicdp     = 0.0
        receipt.basicnet    = 0.0
        receipt.sef         = 0.0
        receipt.sefint      = 0.0
        receipt.sefdisc     = 0.0
        receipt.sefdp       = 0.0
        receipt.sefnet      = 0.0
        
        items.each { 
            receipt.basic       += it.basic     
            receipt.basicint    += it.basicint
            receipt.basicdisc   += it.basicdisc
            receipt.basicdp     += (it.basicint - it.basicdisc )
            receipt.basicnet    += (it.basic + it.basicint - it.basicdisc )
            receipt.sef         += it.sef 
            receipt.sefint      += it.sefint 
            receipt.sefdisc     += it.sefdisc 
            receipt.sefdp       += (it.sefint - it.sefdisc)
            receipt.sefnet      += (it.sef + it.sefint - it.sefdisc )
        }
    }
    
    
    void updateLedgerLastYearQtrPaid( params ) {
        em.sqlContext.createNamedExecutor('rptreceipt:updateLedgerLastYearQtrPaid').setParameters( params ).execute()
    }
    
    Map createRPTPayment( receipt, item ) {
        def pmt = [:]
        pmt.putAll( item )
        pmt.objid       = 'RP' + new UID()
        pmt.schemaname      = 'rptpayment'
        pmt.schemaversion   = '1.0'
        pmt.rptledgerid     = item.objid
        pmt.opener          = 'rptonline'
        pmt.mode            = 'ONLINE'
        pmt.dtposted        = dateSvc.serverDate
        pmt.receiptid       = receipt.objid
        pmt.receiptdate     = receipt.info.txndate
        pmt.receiptno       = receipt.info.serialno
        pmt.collectorid     = receipt.info.collectorid
        pmt.collectorname   = receipt.info.collectorname
        pmt.collectortitle  = receipt.info.collectortitle
        pmt.voided          = false
        pmt.fromyear        = (int)pmt.fromyear
        pmt.fromqtr         = (int)pmt.fromqtr
        pmt.basicpartial    = 0.0
        pmt.sefpartial      = 0.0
        pmt.period          = item.period 
        return pmt 
    }
    
    Map createRPTPaymentDetail( receipt, rptpayment, detail ) {
        def pmtdetail = [:]
        pmtdetail.putAll( detail )
        pmtdetail.objid         = 'RPD' + new UID()
        pmtdetail.schemaname    = 'rptpayment:rptpaymentdetail'
        pmtdetail.schemaversion = '1.0'
        pmtdetail.receiptid     = receipt.objid
        pmtdetail.basicpartial  = 0.0
        pmtdetail.sefpartial    = 0.0
        return pmtdetail 
    }
    
    
    
    void buildReceiptItems( receipt, items ) {
        items.each { item -> 
            //group details according to acctid for basic, basicint, sef and sefint 
            //then add receiptitem entry per group with the total amount 
            buildItemsFromMap( receipt, item, 'basic', item.details.groupBy{ it.basicacctid } )
            buildItemsFromMap( receipt, item, 'basicint', item.details.groupBy{ it.basicintacctid } )
            buildItemsFromMap( receipt, item, 'sef', item.details.groupBy{ it.sefacctid } )
            buildItemsFromMap( receipt, item, 'sefint', item.details.groupBy{ it.sefintacctid } )
        }
    }
    
    void buildItemsFromMap( receipt, item, field, mapgroup) {
        mapgroup.keySet().each { mkey ->
            if( mkey ) {
                def acctinfo = em.sqlContext.createNamedQuery('rptreceipt:getIncomeAccountInfo').setParameter('objid', mkey).singleResult
                if( !acctinfo ) throw new Exception("Account with ID No. $mkey does not exists.")
                
                def items = mapgroup[mkey]
                def rctitem = [
                    objid       : 'RI' + new UID(),
                    amount      : items."$field".sum(),
                    refid       : item.objid,
                ] + acctinfo 
                
                receipt.items.add( rctitem )
            }
        }
    }
    
}
